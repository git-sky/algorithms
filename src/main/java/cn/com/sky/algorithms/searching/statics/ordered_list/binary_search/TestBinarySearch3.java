package cn.com.sky.algorithms.searching.statics.ordered_list.binary_search;

/**
 * <pre>
 * 
 * 给定一个升序排列的自然数数组，数组中包含重复数字，例如：[1,2,2,3,4,4,4,5,6,7,7]。
 * 问题：给定任意自然数，对数组进行二分查找，返回数组正确的位置，给出函数实现。
 * 注：连续相同的数字，返回第一个匹配位置还是最后一个匹配位置，由函数传入参数决定。
 * 
 * 
 * 二分查找实现，需要注意的问题
 * 
 * 问题一：是否检查参数的有效性
 * 
 * 大量的试卷，在给出此问题的解决算法时，直接拿着low，high参数开始进行计算，但是却没有检查low/high参数。
 * low/high是否相同，数组中是否存在记录？low/high构成的区间是否有效？代码的鲁棒性不足。
 * 
 * 在数据库的二分查找实现中，一般是对一个索引页面进行二分查找。
 * 索引页面中有可能根本不存在用户的记录(索引页面中的记录全部被删除，又没有与兄弟页面合并时)，
 * 此时，low/high均为0，此时如果根据low/high计算出来的mid进行记录的读取，就存在逻辑错误。
 * 
 * 问题二：二分查找中值的计算
 * 这是一个经典的话题，如何计算二分查找中的中值？一般给出了两种计算方法：
 * 
 * 算法一： mid = (low + high) / 2
 * 算法二： mid = low + (high – low)/2
 * 
 * 乍看起来，算法一简洁，算法二提取之后，跟算法一没有什么区别。但是实际上，区别是存在的。
 * 算法一的做法，在极端情况下，(low + high)存在着溢出的风险，进而得到错误的mid结果，导致程序错误。
 * 而算法二能够保证计算出来的mid，一定大于low，小于high，不存在溢出的问题。
 * 
 * 问题三：递归实现二分查找
 * 
 * 超过一半的试卷，使用了递归调用的方式实现二分查找。不能说递归实现有错，而是在于实现效率问题。
 * 众所周知，递归调用存在着压栈/出栈的开销，其效率是比较低下的。
 * 而以数据库这样一个极端优化代码效率，提供快速查询响应的系统来说，效率是第一位的。
 * 不建议使用递归方式实现二分查找，至少在数据库内核实现中是不允许使用的。
 * 据我所知，所有的开源数据库系统，例如：InnoDB，PostgreSQL都未采用递归方式实现二分查找。
 * 
 * 
 * 参考：http://hedengcheng.com/?p=595
 * 
 * </pre>
 * 
 */
public class TestBinarySearch3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
